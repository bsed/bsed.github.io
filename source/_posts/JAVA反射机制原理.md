---
title: "JAVA反射机制原理"
categories: [ "Java" ]
tags: [ "java","反射" ]
draft: false
slug: "the-principle-of-the-java-reflection-mechanism"
date: "2013-01-15 10:44:00"
---

运行时类型识别(Run-time Type Identification, RTTI)主要有两种方式，一种是我们在编译时和运行时已经知道了所有的类型，另外一种是功能强大的“反射”机制。

要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的，这项工作是由“Class对象”完成的，它包含了与类有关的信息。类是程序的重要组成部分，每个类都有一个Class对象，每当编写并编译了一个新类就会产生一个Class对象，它被保存在一个同名的.class文件中。在运行时，当我们想生成这个类的对象时，运行这个程序的Java虚拟机(JVM)会确认这个类的Class对象是否已经加载，如果尚未加载，JVM就会根据类名查找.class文件，并将其载入，一旦这个类的Class对象被载入内存，它就被用来创建这个类的所有对象。一般的RTTI形式包括三种：


<!--more-->


1.传统的类型转换。如“(Apple)Fruit”，由RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个ClassCastException异常。

2.通过Class对象来获取对象的类型。如

    Class c = Class.forName("Apple");
    Object o = c.newInstance();

3.通过关键字instanceof或Class.isInstance()方法来确定对象是否属于某个特定类型的实例，准确的说，应该是instanceof / Class.isInstance()可以用来确定对象是否属于某个特定类及其所有基类的实例，这和equals() / ==不一样，它们用来比较两个对象是否属于同一个类的实例，没有考虑继承关系。
## 反射 ##

 如果不知道某个对象的类型，可以通过RTTI来获取，但前提是这个类型在编译时必须已知，这样才能使用RTTI来识别。即在编译时，编译器必须知道所有通过RTTI来处理的类。

使用反射机制可以不受这个限制，它主要应用于两种情况，第一个是“基于构件的编程”，在这种编程方式中，将使用某种基于快速应用开发(RAD)的应用构建工具来构建项目。这是现在最常见的可视化编程方法，通过代表不同组件的图标拖动到图板上来创建程序，然后设置构件的属性值来配置它们。这种配置要求构件都是可实例化的，并且要暴露其部分信息，使得程序员可以读取和设置构件的值。当处理GUI时间的构件时还必须暴露相关方法的细细，以便RAD环境帮助程序员覆盖这些处理事件的方法。在这里，就要用到反射的机制来检查可用的方法并返回方法名。Java通过JavaBeans提供了基于构件的编程架构。

第二种情况，在运行时获取类的信息的另外一个动机，就是希望能够提供在跨网络的远程平台上创建和运行对象的能力。这被成为远程调用(RMI)，它允许一个Java程序将对象分步在多台机器上，这种分步能力将帮助开发人员执行一些需要进行大量计算的任务，充分利用计算机资源，提高运行速度。

Class支持反射，java.lang.reflect中包含了Field/Method/Constructor类，每个类都实现了Member接口。这些类型的对象都是由JVM在运行时创建的，用来表示未知类里对应的成员。如可以用Constructor类创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。同时，还可以调用getFields()、getMethods()、getConstructors()等方法来返回表示字段、方法以及构造器的对象数组。这样，未知的对象的类信息在运行时就能被完全确定下来，而在编译时不需要知道任何信息。

另外，RTTI有时能解决效率问题。当程序中使用多态给程序的运行带来负担的时候，可以使用RTTI编写一段代码来提高效率。
