---
title:  MySQL的索引使用
date: 2008-11-02 08:37:00
updated: 2015-11-01 08:48:58
tags: 
- notes
categories: 
- js

---
## 数据库引入了索引

用户对数据库最频繁的操作是进行**数据查询**。一般情况下，数据库在进行查询操作时需要对整个表进行数据搜索。当表中的数据很多时，搜索数据就需要很长的时间，这就造成了服务器的资源浪费。为了提高检索数据的能力，数据库引入了索引机制。

**有关“索引”的比喻**

从某种程度上，可以把数据库看作一本书，把索引看作书的目录，通过目录查找书中的信息，显然较没有目录的书方便、快捷。
数据库索引实际是什么？（两部分组成）
索引是一个单独的、物理的数据库结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。

**索引在表中的角色**


<!--more-->


一个表的存储是由两部分组成的，一部分用来存放表的数据页面，另一部分存放索引页面。索引就存放在索引页面上，

**索引高效原理**

通常，索引页面相对于数据页面来说小得多。当进行数据检索时，系统先搜索索引页面，从中找到所需数据的指针，再直接通过指针从数据页面中读取数据。

**索引的分类**

在SQL Server 的数据库中按存储结构的不同将索引分为两类：簇索引（Clustered Index）和非簇索引（Nonclustered Index）。

 1. 簇索引对表的物理数据页中的数据按列进行排序，然后再重新存储到磁盘上，即簇索引与数据是混为一体，的它的叶节点中存储的是实际的数据。由于簇索引对表中的数据一一进行了排序，因此用簇索引查找数据很快。但由于簇索引将表的所有数据完全重新排列了，它所需要的空间也就特别大，大概相当于表中数据所占空间的120%
    。表的数据行只能以一种排序方式存储在磁盘上，所以一个表只能有一个簇索引。
 2. 非簇索引具有与表的数据完全分离的结构，使用非簇索引不用将物理数据页中的数据按列排序。非簇索引的叶节点中存储了组成非簇索引的关键字的值和行定位器。行定位器的结构和存储内容取决于数据的存储方式。如果数据是以簇索引方式存储的，则行定位器中存储的是簇索引的索引键；如果数据不是以簇索引方式存储的，这种方式又称为堆存储方式（Heap
    Structure），则行定位器存储的是指向数据行的指针。非簇索引将行定位器按关键字的值用一定的方式排序，这个顺序与表的行在数据页中的排序是不匹配的。由于非簇索引使用索引页存储因此它比簇索引需要更多的存储空间且检索效率较低但一个表只能建一个簇索引，当用户需要建立多个索引时就需要使用非簇索引了。

 小结：Clustered Index 是与物理数据混在一起并对物理数据进重排，就像使用拼音查字典；Unclustered Index 是与物理数据完全分离的，利用额外空间对关键字进行重排，就像使用部首查字典。


## 数据库索引应用

### 一、索引的概念

    索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。

### 二、索引的特点
    
    索引可以加快数据库的检索速度

    索引降低了数据库插入、修改、删除等维护任务的速度

    索引创建在表上，不能创建在视图上
    索引既可以直接创建，也可以间接创建
    可以在优化隐藏中，使用索引
    使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引
    其他

### 三、索引的优点
    创建唯一性索引，保证数据库表中每一行数据的唯一性
    大大加快数据的检索速度，这也是创建索引的最主要的原因
    加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
    在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
    通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。

### 四、索引的缺点
    创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加

    索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大
    当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度

### 五、索引分类
    #### 直接创建索引和间接创建索引
    直接创建索引： CREATE INDEX mycolumn_index ON mytable (myclumn)
    间接创建索引：定义主键约束或者唯一性键约束，可以间接创建索引

    #### 普通索引和唯一性索引
    普通索引：CREATE INDEX mycolumn_index ON mytable (myclumn)
    唯一性索引：保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用
    CREATE UNIQUE COUSTERED INDEX myclumn_cindex ON mytable(mycolumn)

    #### 单个索引和复合索引
    单个索引：即非复合索引
    复合索引：又叫组合索引，在索引建立语句中同时包含多个字段名，最多16个字段
    CREATE INDEX name_index ON username(firstname,lastname)

    #### 聚簇索引和非聚簇索引(聚集索引，群集索引)
    聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列
    CREATE CLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn) WITH
    ALLOW_DUP_ROW(允许有重复记录的聚簇索引)
    非聚簇索引：CREATE UNCLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn)

### 六、索引的使用

   当字段数据更新频率较低，查询使用频率较高并且存在大量重复值是建议使用聚簇索引

   经常同时存取多列，且每列都含有重复值可考虑建立组合索引

   复合索引的前导列一定好控制好，否则无法起到索引的效果。如果查询时前导列不在查询条件中则该复合索引不会被使用。前导列一定是使用最频繁的列

   多表操作在被实际执行前，查询优化器会根据连接条件，列出几组可能的连接方案并从中找出系统开销最小的最佳方案。连接条件要充份考虑带有索引的表、行数多的表；内外表的选择可由公式：外层表中的匹配行数*内层表中每一次查找的次数确定，乘积最小为最佳方案

   where子句中对列的任何操作结果都是在sql运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引；如果这些结果在查询编译时就能得到，那么就可以被sql优化器优化，使用索引，避免表搜索(例：select * from record where substring(card_no,1,4)=’5378’
&& select * from record where card_no like ’5378%’)任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边

   where条件中的’in’在逻辑上相当于’or’，所以语法分析器会将in ('0','1')转化为column='0' or column='1'来执行。我们期望它会根据每个or子句分别查找，再将结果相加，这样可以利用column上的索引；但实际上它却采用了"or策略"，即先取出满足每个or子句的行，存入临时数据库的工作表中，再建立唯一索引以去掉重复行，最后从这个临时表中计算结果。因此，实际过程没有利用column上索引，并且完成时间还要受tempdb数据库性能的影响。in、or子句常会使用工作表，使索引失效；如果不产生大量重复值，可以考虑把子句拆开；拆开的子句中应该包含索引

   要善于使用存储过程，它使sql变得更加灵活和高效
